doc_title = "JSON Simplates"
doc_next = []
[----------------------------------------]
{% extends doc.html %}
{% block doc %}

<p>Aspen has no special support for using <a href="/simplates/">simplates</a> to
serve JSON resources; they're Rendered or Negotiated simplates like any other.
What it <em>does</em> do is ship with a 'json_dumps' renderer that will eval
and then call json.dumps on the contents of the template section.  For example,
a simplate like:

<pre>
[---] via json_dumps
{ 'Greetings': 'pro' + 'gram!' }
</pre>

will output JSON of <code>{ "Greetings": "program!" }</code>.<p>

Note that it will also set the Content-Type to the system-configured JSON Content-Type,
if no content-type has been specified.

<p>Aspen will serialize instances of the following types.  Instances of any
other type will raise <code>TypeError</code>, so be sure to pre-process your
output if it contains anything else.</p>

<ul>
    <li><code>bool</code></li>
    <li><code>complex</code> (serialized to two floats, [real, imaginary])</li>
    <li><code>datetime.datetime</code> (serialized to <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>)</li>
    <li><code>float</code></li>
    <li><code>int</code></li>
    <li><code>long</code></li>
    <li><code>None</code></li>
    <li><code>str</code></li>
    <li><code>unicode</code></li>
</ul>


<h4>Example</h4>

<p>Make a <code>greetings.spt</code> file with this content:</p>

<pre>import random
n = random.choice(range(10))
extra_excitement = "!" * n
\[---] via json_dumps
{'Greetings': 'program!' + extra_excitement}</pre>


<p>Notice that there is no third page. Now <a
    href="http://localhost:8080/greetings">hit this</a> in your
browser:</p>

{{ screenshot("json") }}


<h3>Configuring Content-Type</h3>

<p>By default Aspen sets <code>Content-Type</code> to
<code>application/json</code> for JSON simplates. If you would like to use
something else while preserving special JSON simplate handling, don&rsquo;t use
the normal <a href="/mime.types/"><code>mime.types</code></a> configuration
file. Aspen uses the <code>mime.types</code> mapping to determine that a
simplate is a JSON simplate (actually, any file with an extension that you
configure to have a mimetype of <code>application/json</code> will be treated
as a JSON simplate).  Instead, you should set the <code>media_type_json</code>
key in <code><a
        href="/configure-aspen.py/">configure-aspen.py</a></code>, like so:</p>

<pre>website.media_type_json = "application/javascript"</pre>

<p>If you need to bypass special JSON simplate handling altogether, you can use
<a href="/mime.types/"><code>mime.types</code></a> to set the <code>json</code>
extension to something besides <code>application/json</code> that browsers will
still process as JSON:</p>

<pre>application/javascript     json</pre>

<p>This behavior holds true for both static and dynamic JSON simplates.</p>


<a name="libraries"></a>
<h3>Supported JSON Libraries</h3>

<p>Aspen will prefer <a
    href="http://pypi.python.org/pypi/simplejson/"><code>simplejson</code></a>
if it is available, falling back to the standard library&rsquo;s <a
    href="http://docs.python.org/library/json.html"><code>json</code></a>
module, which was added in Python 2.6. The latter is a more or less out-of-date
version of the former. It also doesn&rsquo;t have any C speedups. If Aspen
can&rsquo;t find either, then dynamic JSON simplates will raise an
<code>ImportError</code>, though static JSON simplates will still work.</p>


<a name="encoders"></a>
<h3>Custom Encoders</h3>

<p>It&rsquo;s fairly common to want to add encoders for custom classes or
classes otherwise unknown to one or another version of simplejson. To this end,
Aspen provides an API to manage a registry of encoders. These functions can be
imported <code>from aspen.json</code>:</p>

<pre>
def register_encoder(cls, encode):
    """Register the encode function for cls.

    An encoder should take an instance of cls and return something
    basically serializable (strings, lists, dictionaries).

    """

def unregister_encoder(cls):
    """Given a class, remove any encoder that has been registered for it.
    """
</pre>

<p>These functions don&rsquo;t affect the underlying simplejson library, only
the Aspen abstraction layer. So if for example you have a simplejson that knows
about Decimal objects (support for which was added in version 2.1 of the
library), then if you register a custom encoder for Decimals, Aspen will use
that where appropriate, and if you unregister it, the underlying implementation
will be used again. Furthermore, if you use the simplejson library directly,
the encoders registered with Aspen won&rsquo;t be used at all.</p>

{% end %}

